{"ast":null,"code":"/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function () {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = \"SyntaxError\";\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n  peg$subclass(peg$SyntaxError, Error);\n  peg$SyntaxError.buildMessage = function (expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n      literal: function (expectation) {\n        return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n      },\n      \"class\": function (expectation) {\n        var escapedParts = \"\",\n          i;\n        for (i = 0; i < expectation.parts.length; i++) {\n          escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n        }\n        return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n      },\n      any: function (expectation) {\n        return \"any character\";\n      },\n      end: function (expectation) {\n        return \"end of input\";\n      },\n      other: function (expectation) {\n        return expectation.description;\n      }\n    };\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n    function literalEscape(s) {\n      return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n        return '\\\\x0' + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n        return '\\\\x' + hex(ch);\n      });\n    }\n    function classEscape(s) {\n      return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n        return '\\\\x0' + hex(ch);\n      }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n        return '\\\\x' + hex(ch);\n      });\n    }\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n        i,\n        j;\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n      descriptions.sort();\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n        default:\n          return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n      }\n    }\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n    var peg$FAILED = {},\n      peg$startRuleFunctions = {\n        Start: peg$parseStart\n      },\n      peg$startRuleFunction = peg$parseStart,\n      peg$c0 = function (statements) {\n        return buildAST('Program', {\n          body: statements\n        });\n      },\n      peg$c1 = \"Print\",\n      peg$c2 = peg$literalExpectation(\"Print\", false),\n      peg$c3 = \"(\",\n      peg$c4 = peg$literalExpectation(\"(\", false),\n      peg$c5 = \")\",\n      peg$c6 = peg$literalExpectation(\")\", false),\n      peg$c7 = function (value) {\n        return buildAST('PrintStatement', {\n          value\n        });\n      },\n      peg$c8 = function (expr) {\n        return buildAST('ExpressionStatement', {\n          expression: expr\n        });\n      },\n      peg$c9 = \"\\\"\",\n      peg$c10 = peg$literalExpectation(\"\\\"\", false),\n      peg$c11 = /^[^\"]/,\n      peg$c12 = peg$classExpectation([\"\\\"\"], true, false),\n      peg$c13 = function (value) {\n        return buildAST('StringLiteral', {\n          value: value.join('')\n        });\n      },\n      peg$c14 = /^[0-9]/,\n      peg$c15 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c16 = \".\",\n      peg$c17 = peg$literalExpectation(\".\", false),\n      peg$c18 = function (value) {\n        return buildAST('NumberLiteral', {\n          value: parseFloat(value)\n        });\n      },\n      peg$c19 = /^[a-zA-Z_]/,\n      peg$c20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], \"_\"], false, false),\n      peg$c21 = /^[a-zA-Z0-9_]/,\n      peg$c22 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false),\n      peg$c23 = function (name) {\n        return buildAST('Identifier', {\n          name\n        });\n      },\n      peg$c24 = peg$otherExpectation(\"whitespace\"),\n      peg$c25 = /^[ \\t\\n\\r]/,\n      peg$c26 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n      peg$currPos = 0,\n      peg$savedPos = 0,\n      peg$posDetailsCache = [{\n        line: 1,\n        column: 1\n      }],\n      peg$maxFailPos = 0,\n      peg$maxFailExpected = [],\n      peg$silentFails = 0,\n      peg$result;\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n    }\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n      throw peg$buildSimpleError(message, location);\n    }\n    function peg$literalExpectation(text, ignoreCase) {\n      return {\n        type: \"literal\",\n        text: text,\n        ignoreCase: ignoreCase\n      };\n    }\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return {\n        type: \"class\",\n        parts: parts,\n        inverted: inverted,\n        ignoreCase: ignoreCase\n      };\n    }\n    function peg$anyExpectation() {\n      return {\n        type: \"any\"\n      };\n    }\n    function peg$endExpectation() {\n      return {\n        type: \"end\"\n      };\n    }\n    function peg$otherExpectation(description) {\n      return {\n        type: \"other\",\n        description: description\n      };\n    }\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n        p;\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column\n        };\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n          p++;\n        }\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails = peg$computePosDetails(endPos);\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n      peg$maxFailExpected.push(expected);\n    }\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n    }\n    function peg$parseStart() {\n      var s0;\n      s0 = peg$parseProgram();\n      return s0;\n    }\n    function peg$parseProgram() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseStatement();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseStatement();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseStatement() {\n      var s0;\n      s0 = peg$parsePrintStatement();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseExpressionStatement();\n      }\n      return s0;\n    }\n    function peg$parsePrintStatement() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c2);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c4);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseExpression();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c5;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) {\n                      peg$fail(peg$c6);\n                    }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c7(s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseExpressionStatement() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = peg$parseExpression();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseExpression() {\n      var s0;\n      s0 = peg$parseStringLiteral();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNumberLiteral();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseIdentifier();\n        }\n      }\n      return s0;\n    }\n    function peg$parseStringLiteral() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c10);\n        }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c11.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c12);\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c11.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c12);\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c9;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c10);\n            }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      return s0;\n    }\n    function peg$parseNumberLiteral() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = [];\n      if (peg$c14.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c15);\n        }\n      }\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c15);\n            }\n          }\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s5 = peg$c16;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c17);\n          }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c15);\n            }\n          }\n          if (s7 !== peg$FAILED) {\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              if (peg$c14.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c15);\n                }\n              }\n            }\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parseIdentifier() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (peg$c19.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c20);\n        }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c21.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c22);\n          }\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$c21.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c22);\n            }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n      return s0;\n    }\n    function peg$parse_() {\n      var s0, s1;\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c25.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c26);\n        }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c25.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c26);\n          }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c24);\n        }\n      }\n      return s0;\n    }\n    function buildAST(type, props) {\n      return {\n        type,\n        ...props\n      };\n    }\n    peg$result = peg$startRuleFunction();\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n      throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n});","map":{"version":3,"names":["root","factory","define","amd","module","exports","peg$subclass","child","parent","ctor","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","Error","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","i","parts","length","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","s","replace","describeExpectation","type","describeExpected","descriptions","j","sort","slice","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","Start","peg$parseStart","peg$startRuleFunction","peg$c0","statements","buildAST","body","peg$c1","peg$c2","peg$literalExpectation","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","value","peg$c8","expr","expression","peg$c9","peg$c10","peg$c11","peg$c12","peg$classExpectation","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","peg$c18","parseFloat","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$otherExpectation","peg$c25","peg$c26","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","substring","peg$computeLocation","peg$buildStructuredError","error","peg$buildSimpleError","ignoreCase","peg$anyExpectation","peg$endExpectation","peg$computePosDetails","pos","details","p","startPos","endPos","startPosDetails","endPosDetails","start","offset","peg$fail","push","s0","peg$parseProgram","s1","s2","peg$parseStatement","peg$parsePrintStatement","peg$parseExpressionStatement","s3","s4","s5","s6","s7","s8","substr","peg$parse_","peg$parseExpression","peg$parseStringLiteral","peg$parseNumberLiteral","peg$parseIdentifier","test","charAt","props","SyntaxError","parse"],"sources":["/Users/johanfortus/Documents/Projects/Verse Playground/src/verse-parser.js"],"sourcesContent":["/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    module.exports = factory();\n  }\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { Start: peg$parseStart },\n        peg$startRuleFunction  = peg$parseStart,\n\n        peg$c0 = function(statements) {\n            return buildAST('Program', { body: statements });\n          },\n        peg$c1 = \"Print\",\n        peg$c2 = peg$literalExpectation(\"Print\", false),\n        peg$c3 = \"(\",\n        peg$c4 = peg$literalExpectation(\"(\", false),\n        peg$c5 = \")\",\n        peg$c6 = peg$literalExpectation(\")\", false),\n        peg$c7 = function(value) {\n            return buildAST('PrintStatement', { value });\n          },\n        peg$c8 = function(expr) {\n            return buildAST('ExpressionStatement', { expression: expr });\n          },\n        peg$c9 = \"\\\"\",\n        peg$c10 = peg$literalExpectation(\"\\\"\", false),\n        peg$c11 = /^[^\"]/,\n        peg$c12 = peg$classExpectation([\"\\\"\"], true, false),\n        peg$c13 = function(value) {\n            return buildAST('StringLiteral', { value: value.join('') });\n          },\n        peg$c14 = /^[0-9]/,\n        peg$c15 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c16 = \".\",\n        peg$c17 = peg$literalExpectation(\".\", false),\n        peg$c18 = function(value) {\n            return buildAST('NumberLiteral', { value: parseFloat(value) });\n          },\n        peg$c19 = /^[a-zA-Z_]/,\n        peg$c20 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], \"_\"], false, false),\n        peg$c21 = /^[a-zA-Z0-9_]/,\n        peg$c22 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\"], false, false),\n        peg$c23 = function(name) {\n            return buildAST('Identifier', { name });\n          },\n        peg$c24 = peg$otherExpectation(\"whitespace\"),\n        peg$c25 = /^[ \\t\\n\\r]/,\n        peg$c26 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseStart() {\n      var s0;\n\n      s0 = peg$parseProgram();\n\n      return s0;\n    }\n\n    function peg$parseProgram() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parseStatement();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parseStatement();\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseStatement() {\n      var s0;\n\n      s0 = peg$parsePrintStatement();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseExpressionStatement();\n      }\n\n      return s0;\n    }\n\n    function peg$parsePrintStatement() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 5) === peg$c1) {\n        s1 = peg$c1;\n        peg$currPos += 5;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c2); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 40) {\n            s3 = peg$c3;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c4); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parse_();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parseExpression();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s7 = peg$c5;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c6); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    s8 = peg$parse_();\n                    if (s8 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c7(s5);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseExpressionStatement() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parseExpression();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse_();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseExpression() {\n      var s0;\n\n      s0 = peg$parseStringLiteral();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNumberLiteral();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseIdentifier();\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseStringLiteral() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c9;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c10); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c11.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c12); }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          if (peg$c11.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c12); }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c9;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c10); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseNumberLiteral() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      s3 = [];\n      if (peg$c14.test(input.charAt(peg$currPos))) {\n        s4 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c15); }\n      }\n      if (s4 !== peg$FAILED) {\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n        }\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s5 = peg$c16;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c17); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          if (peg$c14.test(input.charAt(peg$currPos))) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c15); }\n          }\n          if (s7 !== peg$FAILED) {\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              if (peg$c14.test(input.charAt(peg$currPos))) {\n                s7 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s7 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c15); }\n              }\n            }\n          } else {\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = [s5, s6];\n            s4 = s5;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c18(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseIdentifier() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (peg$c19.test(input.charAt(peg$currPos))) {\n        s3 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c20); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        if (peg$c21.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c22); }\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          if (peg$c21.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c22); }\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          s3 = [s3, s4];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c23(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c25.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        if (peg$c25.test(input.charAt(peg$currPos))) {\n          s1 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c26); }\n        }\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c24); }\n      }\n\n      return s0;\n    }\n\n\n      function buildAST(type, props) {\n        return { type, ...props };\n      }\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}