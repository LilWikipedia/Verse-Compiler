{"ast":null,"code":"export class VerseInterpreter {\n  constructor() {\n    this.output = '';\n    this.symbolTable = new Map();\n  }\n  interpret(ast) {\n    this.output = '';\n    console.log('Interpreter received AST:', JSON.stringify(ast, null, 2));\n    if (!ast || typeof ast !== 'object' || !Array.isArray(ast.body)) {\n      throw new Error('Invalid AST structure: Expected an object with a body array');\n    }\n    this.visitProgram(ast);\n    return this.output;\n  }\n  visitProgram(program) {\n    for (const statement of program.body) {\n      this.visitStatement(statement);\n    }\n  }\n  visitStatement(statement) {\n    console.log('Visiting statement:', JSON.stringify(statement, null, 2));\n    switch (statement.type) {\n      case 'VariableDeclaration':\n        this.visitVariableDeclaration(statement);\n        break;\n      case 'SetStatement':\n        this.visitSetStatement(statement);\n        break;\n      case 'PrintStatement':\n        this.visitPrintStatement(statement);\n        break;\n      default:\n        throw new Error(`Unsupported statement type: ${statement.type}`);\n    }\n  }\n  visitVariableDeclaration(declaration) {\n    console.log('Variable Declaration:', JSON.stringify(declaration, null, 2));\n    const value = this.evaluateExpression(declaration.value);\n    console.log(`Storing variable ${declaration.name.name} with type ${declaration.varType.name} and value ${value}`);\n    this.symbolTable.set(declaration.name.name, {\n      type: declaration.varType.name,\n      value\n    });\n  }\n  visitSetStatement(setStatement) {\n    const value = this.evaluateExpression(setStatement.value);\n    if (!this.symbolTable.has(setStatement.name.name)) {\n      throw new Error(`Cannot set undefined variable: ${setStatement.name.name}`);\n    }\n    const variable = this.symbolTable.get(setStatement.name.name);\n    variable.value = value;\n  }\n  visitPrintStatement(printStatement) {\n    console.log('Print Statement:', JSON.stringify(printStatement, null, 2));\n    const value = this.evaluateInterpolatedString(printStatement.value);\n    console.log('Evaluated Print Statement:', value);\n    this.output += value + '\\n';\n  }\n  evaluateInterpolatedString(interpolatedString) {\n    console.log('Evaluating Interpolated String:', JSON.stringify(interpolatedString, null, 2));\n    return interpolatedString.parts.map(part => {\n      if (part.type === 'TextPart') {\n        return part.text;\n      } else if (part.type === 'InterpolatedExpression') {\n        const value = this.evaluateExpression(part.expression);\n        console.log(`Interpolated Expression Result: ${value}`);\n        return String(value);\n      }\n    }).join('');\n  }\n  evaluateExpression(expression) {\n    console.log('Evaluating expression:', JSON.stringify(expression, null, 2));\n    let result;\n    switch (expression.type) {\n      case 'StringLiteral':\n        result = expression.value;\n        break;\n      case 'IntegerLiteral':\n        result = parseInt(expression.value, 10);\n        break;\n      case 'FloatLiteral':\n        result = parseFloat(expression.value);\n        break;\n      case 'Identifier':\n        if (this.symbolTable.has(expression.name)) {\n          result = this.symbolTable.get(expression.name).value;\n        } else {\n          throw new Error(`Undefined variable: ${expression.name}`);\n        }\n        break;\n      default:\n        throw new Error(`Unsupported expression type: ${expression.type}`);\n    }\n    console.log(`Expression ${expression.type} evaluated to:`, result);\n    return result;\n  }\n}","map":{"version":3,"names":["VerseInterpreter","constructor","output","symbolTable","Map","interpret","ast","console","log","JSON","stringify","Array","isArray","body","Error","visitProgram","program","statement","visitStatement","type","visitVariableDeclaration","visitSetStatement","visitPrintStatement","declaration","value","evaluateExpression","name","varType","set","setStatement","has","variable","get","printStatement","evaluateInterpolatedString","interpolatedString","parts","map","part","text","expression","String","join","result","parseInt","parseFloat"],"sources":["/Users/johanfortus/Documents/Projects/Verse Playground/src/verse-interpreter.js"],"sourcesContent":["export class VerseInterpreter {\n    constructor() {\n      this.output = '';\n      this.symbolTable = new Map();\n    }\n  \n    interpret(ast) {\n      this.output = '';\n      console.log('Interpreter received AST:', JSON.stringify(ast, null, 2));\n      \n      if (!ast || typeof ast !== 'object' || !Array.isArray(ast.body)) {\n        throw new Error('Invalid AST structure: Expected an object with a body array');\n      }\n      \n      this.visitProgram(ast);\n      return this.output;\n    }\n  \n    visitProgram(program) {\n      for (const statement of program.body) {\n        this.visitStatement(statement);\n      }\n    }\n  \n    visitStatement(statement) {\n      console.log('Visiting statement:', JSON.stringify(statement, null, 2));\n      switch (statement.type) {\n        case 'VariableDeclaration':\n          this.visitVariableDeclaration(statement);\n          break;\n        case 'SetStatement':\n          this.visitSetStatement(statement);\n          break;\n        case 'PrintStatement':\n          this.visitPrintStatement(statement);\n          break;\n        default:\n          throw new Error(`Unsupported statement type: ${statement.type}`);\n      }\n    }\n  \n    visitVariableDeclaration(declaration) {\n      console.log('Variable Declaration:', JSON.stringify(declaration, null, 2));\n      const value = this.evaluateExpression(declaration.value);\n      console.log(`Storing variable ${declaration.name.name} with type ${declaration.varType.name} and value ${value}`);\n      this.symbolTable.set(declaration.name.name, { type: declaration.varType.name, value });\n    }\n  \n    visitSetStatement(setStatement) {\n      const value = this.evaluateExpression(setStatement.value);\n      if (!this.symbolTable.has(setStatement.name.name)) {\n        throw new Error(`Cannot set undefined variable: ${setStatement.name.name}`);\n      }\n      const variable = this.symbolTable.get(setStatement.name.name);\n      variable.value = value;\n    }\n  \n    visitPrintStatement(printStatement) {\n      console.log('Print Statement:', JSON.stringify(printStatement, null, 2));\n      const value = this.evaluateInterpolatedString(printStatement.value);\n      console.log('Evaluated Print Statement:', value);\n      this.output += value + '\\n';\n    }\n  \n    evaluateInterpolatedString(interpolatedString) {\n      console.log('Evaluating Interpolated String:', JSON.stringify(interpolatedString, null, 2));\n      return interpolatedString.parts.map(part => {\n        if (part.type === 'TextPart') {\n          return part.text;\n        } else if (part.type === 'InterpolatedExpression') {\n          const value = this.evaluateExpression(part.expression);\n          console.log(`Interpolated Expression Result: ${value}`);\n          return String(value);\n        }\n      }).join('');\n    }\n  \n    evaluateExpression(expression) {\n      console.log('Evaluating expression:', JSON.stringify(expression, null, 2));\n      let result;\n      switch (expression.type) {\n        case 'StringLiteral':\n          result = expression.value;\n          break;\n        case 'IntegerLiteral':\n          result = parseInt(expression.value, 10);\n          break;\n        case 'FloatLiteral':\n          result = parseFloat(expression.value);\n          break;\n        case 'Identifier':\n          if (this.symbolTable.has(expression.name)) {\n            result = this.symbolTable.get(expression.name).value;\n          } else {\n            throw new Error(`Undefined variable: ${expression.name}`);\n          }\n          break;\n        default:\n          throw new Error(`Unsupported expression type: ${expression.type}`);\n      }\n      console.log(`Expression ${expression.type} evaluated to:`, result);\n      return result;\n    }\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}