{"ast":null,"code":"export class VerseInterpreter {\n  constructor() {\n    this.output = '';\n    this.symbolTable = new Map();\n  }\n  interpret(ast) {\n    this.output = '';\n    console.log('Received AST:', JSON.stringify(ast, null, 2));\n    this.visitProgram(ast);\n    return this.output;\n  }\n  visitProgram(program) {\n    for (const statement of program.body) {\n      this.visitStatement(statement);\n    }\n  }\n  visitStatement(statement) {\n    console.log('Visiting statement:', statement);\n    switch (statement.type) {\n      case 'VariableDeclaration':\n        this.visitVariableDeclaration(statement);\n        break;\n      case 'PrintStatement':\n        this.visitPrintStatement(statement);\n        break;\n      case 'ExpressionStatement':\n        this.visitExpressionStatement(statement);\n        break;\n      default:\n        throw new Error(`Unsupported statement type: ${JSON.stringify(statement)}`);\n    }\n  }\n  visitVariableDeclaration(declaration) {\n    const value = this.evaluateExpression(declaration.value);\n    this.symbolTable.set(declaration.name.name, value);\n  }\n  visitPrintStatement(printStatement) {\n    const value = this.evaluateInterpolatedString(printStatement.value);\n    this.output += value + '\\n';\n  }\n  visitExpressionStatement(expressionStatement) {\n    this.evaluateExpression(expressionStatement.expression);\n  }\n  evaluateInterpolatedString(interpolatedString) {\n    return interpolatedString.parts.map(part => {\n      if (part.type === 'TextPart') {\n        return part.text;\n      } else if (part.type === 'InterpolatedExpression') {\n        return this.evaluateExpression(part.expression);\n      }\n    }).join('');\n  }\n  evaluateExpression(expression) {\n    console.log('Evaluating expression:', expression);\n    switch (expression.type) {\n      case 'StringLiteral':\n        return expression.value;\n      case 'NumberLiteral':\n        return expression.value.toString();\n      case 'Identifier':\n        if (this.symbolTable.has(expression.name)) {\n          return this.symbolTable.get(expression.name);\n        }\n        throw new Error(`Undefined variable: ${expression.name}`);\n      default:\n        throw new Error(`Unsupported expression type: ${JSON.stringify(expression)}`);\n    }\n  }\n}","map":{"version":3,"names":["VerseInterpreter","constructor","output","symbolTable","Map","interpret","ast","console","log","JSON","stringify","visitProgram","program","statement","body","visitStatement","type","visitVariableDeclaration","visitPrintStatement","visitExpressionStatement","Error","declaration","value","evaluateExpression","set","name","printStatement","evaluateInterpolatedString","expressionStatement","expression","interpolatedString","parts","map","part","text","join","toString","has","get"],"sources":["/Users/johanfortus/Documents/Projects/Verse Playground/src/verse-interpreter.js"],"sourcesContent":["export class VerseInterpreter {\n    constructor() {\n      this.output = '';\n      this.symbolTable = new Map();\n    }\n  \n    interpret(ast) {\n      this.output = '';\n      console.log('Received AST:', JSON.stringify(ast, null, 2));\n      this.visitProgram(ast);\n      return this.output;\n    }\n  \n    visitProgram(program) {\n      for (const statement of program.body) {\n        this.visitStatement(statement);\n      }\n    }\n  \n    visitStatement(statement) {\n      console.log('Visiting statement:', statement);\n      switch (statement.type) {\n        case 'VariableDeclaration':\n          this.visitVariableDeclaration(statement);\n          break;\n        case 'PrintStatement':\n          this.visitPrintStatement(statement);\n          break;\n        case 'ExpressionStatement':\n          this.visitExpressionStatement(statement);\n          break;\n        default:\n          throw new Error(`Unsupported statement type: ${JSON.stringify(statement)}`);\n      }\n    }\n  \n    visitVariableDeclaration(declaration) {\n      const value = this.evaluateExpression(declaration.value);\n      this.symbolTable.set(declaration.name.name, value);\n    }\n  \n    visitPrintStatement(printStatement) {\n      const value = this.evaluateInterpolatedString(printStatement.value);\n      this.output += value + '\\n';\n    }\n  \n    visitExpressionStatement(expressionStatement) {\n      this.evaluateExpression(expressionStatement.expression);\n    }\n  \n    evaluateInterpolatedString(interpolatedString) {\n      return interpolatedString.parts.map(part => {\n        if (part.type === 'TextPart') {\n          return part.text;\n        } else if (part.type === 'InterpolatedExpression') {\n          return this.evaluateExpression(part.expression);\n        }\n      }).join('');\n    }\n  \n    evaluateExpression(expression) {\n      console.log('Evaluating expression:', expression);\n      switch (expression.type) {\n        case 'StringLiteral':\n          return expression.value;\n        case 'NumberLiteral':\n          return expression.value.toString();\n        case 'Identifier':\n          if (this.symbolTable.has(expression.name)) {\n            return this.symbolTable.get(expression.name);\n          }\n          throw new Error(`Undefined variable: ${expression.name}`);\n        default:\n          throw new Error(`Unsupported expression type: ${JSON.stringify(expression)}`);\n      }\n    }\n  }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}